<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Valentine Snake (Pixel Sakura)</title>

  <!-- Google Fonts (romantic + pixel-ish UI) -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg:#1a0f1c;
      --ui:#ffffff;
      --ui2:#ffd2e1;
      --btn:#2b1630;
      --btn2:#3b1f42;
      --accent:#ff4b7d;
    }
    html,body{
      margin:0;
      height:100%;
      background:var(--bg);
      overflow:hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      touch-action:none; /* stop iOS scrolling */
    }
    #wrap{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    canvas{
      width:min(100vw, 1100px);
      height:auto;
      max-height:100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background:transparent;
    }

    /* On-screen D-pad */
    #hud{
      position:fixed;
      left:0;
      right:0;
      bottom:0;
      padding: max(10px, env(safe-area-inset-bottom)) 12px 12px;
      display:flex;
      justify-content:center;
      pointer-events:none; /* let canvas clicks pass through except buttons */
    }
    #dpad{
      pointer-events:auto;
      display:grid;
      grid-template-columns:64px 64px 64px;
      grid-template-rows:64px 64px 64px;
      gap:10px;
      align-items:center;
      justify-items:center;
      user-select:none;
      -webkit-user-select:none;
    }
    .btn{
      width:64px;
      height:64px;
      border:2px solid rgba(255,255,255,0.15);
      border-bottom-color: rgba(0,0,0,0.35);
      border-right-color: rgba(0,0,0,0.25);
      border-radius:14px;
      background:linear-gradient(180deg, var(--btn2), var(--btn));
      color:var(--ui);
      font-family:"Press Start 2P", monospace;
      font-size:18px;
      display:flex;
      align-items:center;
      justify-content:center;
      box-shadow: 0 10px 20px rgba(0,0,0,0.25);
      transform: translateZ(0);
    }
    .btn:active{
      transform: translateY(2px);
      filter:brightness(1.07);
    }
    .btn.hidden{ visibility:hidden; }

    /* small helper label (only for accessibility; not shown) */
    .sr{
      position:absolute;
      width:1px;height:1px;
      padding:0;margin:-1px;
      overflow:hidden;clip:rect(0,0,0,0);
      white-space:nowrap;border:0;
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c" width="384" height="216"></canvas>
  </div>

  <!-- Touch D-pad (shown only during gameplay) -->
  <div id="hud" aria-hidden="false">
    <div id="dpad" role="group" aria-label="Directional controls">
      <button class="btn hidden" tabindex="-1" aria-hidden="true"></button>
      <button class="btn" data-dir="up" aria-label="Up">▲</button>
      <button class="btn hidden" tabindex="-1" aria-hidden="true"></button>

      <button class="btn" data-dir="left" aria-label="Left">◀</button>
      <button class="btn hidden" tabindex="-1" aria-hidden="true"></button>
      <button class="btn" data-dir="right" aria-label="Right">▶</button>

      <button class="btn hidden" tabindex="-1" aria-hidden="true"></button>
      <button class="btn" data-dir="down" aria-label="Down">▼</button>
      <button class="btn hidden" tabindex="-1" aria-hidden="true"></button>
    </div>
  </div>

  <script>
  (() => {
    /**********************************************************************
     * Valentine Snake (single-file)
     * - Pure HTML/CSS/JS, canvas + requestAnimationFrame
     * - Pixel-perfect scaling via low-res internal canvas + pixelated CSS
     * - Touch-friendly D-pad + keyboard arrows
     **********************************************************************/

    // ====== Canvas setup ======
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;

    // Keep internal resolution "chunky" (16:9).
    const W = canvas.width;   // 384
    const H = canvas.height;  // 216

    // ====== Game state machine ======
    const SCENE = {
      MENU_CLOSED: 0,  // closed envelope
      MENU_OPEN: 1,    // opened letter with fancy text
      GAME: 2,         // snake
      SCROLL_ROLLED: 3,// rolled-up scroll
      SCROLL_OPEN: 4   // open scroll + note
    };
    let scene = SCENE.MENU_CLOSED;

    // ====== Responsive canvas sizing (no blur) ======
    function resize() {
      // Keep aspect ratio. We scale in CSS. Internal res stays fixed.
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      // Fit within viewport while respecting aspect ratio.
      const scale = Math.min(vw / W, vh / H);
      const cssW = Math.floor(W * scale);
      const cssH = Math.floor(H * scale);
      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
    }
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // ====== Show/hide D-pad depending on scene ======
    const hud = document.getElementById('hud');
    function updateHudVisibility() {
      hud.style.display = (scene === SCENE.GAME) ? 'flex' : 'none';
    }
    updateHudVisibility();

    // ====== Pixel-art background cache (STATIC) ======
    const bg = document.createElement('canvas');
    bg.width = W; bg.height = H;
    const bgx = bg.getContext('2d');
    bgx.imageSmoothingEnabled = false;

    function drawPixelRect(g, x, y, w, h, color) {
      g.fillStyle = color;
      g.fillRect(x|0, y|0, w|0, h|0);
    }

    function drawBackgroundOnce() {
      // Chunky dusk gradient
      const bands = [
        {y:0,   h:28, c:'#ff6b7a'},
        {y:28,  h:26, c:'#ff8d5d'},
        {y:54,  h:28, c:'#ffb34e'},
        {y:82,  h:34, c:'#ff6f7f'},
        {y:116, h:40, c:'#7b2b68'},
        {y:156, h:60, c:'#3a1741'}
      ];
      for (const b of bands) drawPixelRect(bgx, 0, b.y, W, b.h, b.c);

      // Pixel sun
      const sunX = Math.floor(W * 0.52);
      const sunY = Math.floor(H * 0.33);
      const sunR = 18;
      for (let y=-sunR; y<=sunR; y++) {
        for (let x=-sunR; x<=sunR; x++) {
          if (x*x + y*y <= sunR*sunR) {
            // chunky pixels by painting 2x2 blocks
            const px = sunX + x;
            const py = sunY + y;
            if ((x+y) % 2 === 0) drawPixelRect(bgx, px, py, 2, 2, '#fff2b8');
          }
        }
      }
      // Sun glow bands
      drawPixelRect(bgx, 0, sunY+10, W, 2, 'rgba(255,240,190,0.25)');
      drawPixelRect(bgx, 0, sunY+20, W, 2, 'rgba(255,240,190,0.18)');

      // Chunky clouds
      function cloud(cx, cy, w, h, c1, c2) {
        for (let i=0;i<14;i++){
          const rx = (Math.random()*w - w/2)|0;
          const ry = (Math.random()*h - h/2)|0;
          const rw = (8 + Math.random()*18)|0;
          const rh = (6 + Math.random()*12)|0;
          drawPixelRect(bgx, cx+rx, cy+ry, rw, rh, c1);
          drawPixelRect(bgx, cx+rx+2, cy+ry+2, rw-4, rh-4, c2);
        }
      }
      // Deterministic-ish (seedless random would differ on reload; acceptable for "static" per load)
      cloud(86, 64, 120, 30, 'rgba(255,210,210,0.35)', 'rgba(255,240,240,0.25)');
      cloud(290, 74, 140, 34, 'rgba(255,210,210,0.35)', 'rgba(255,240,240,0.25)');

      // Distant hills silhouette
      for (let x=0;x<W;x+=4){
        const t = x/W;
        const y = 118 + Math.floor(10*Math.sin(t*6.2) + 6*Math.sin(t*13.5));
        drawPixelRect(bgx, x, y, 4, H-y, 'rgba(58,18,62,0.65)');
      }

      // Sakura branches (top corners)
      function branchLeft() {
        // main limb
        for (let i=0;i<22;i++){
          drawPixelRect(bgx, 0+i*4, 10+i*2, 6, 4, '#2a0d2e');
          drawPixelRect(bgx, 2+i*4, 12+i*2, 4, 2, '#3b1441');
        }
        // blossoms
        for (let i=0;i<34;i++){
          const x = 10 + (Math.random()*150)|0;
          const y = 6 + (Math.random()*64)|0;
          drawPixelRect(bgx, x, y, 4, 4, '#ffb8cf');
          drawPixelRect(bgx, x+1, y+1, 2, 2, '#ffe6ef');
        }
      }
      function branchRight() {
        for (let i=0;i<22;i++){
          drawPixelRect(bgx, W-6-i*4, 10+i*2, 6, 4, '#2a0d2e');
          drawPixelRect(bgx, W-6-i*4, 12+i*2, 4, 2, '#3b1441');
        }
        for (let i=0;i<34;i++){
          const x = (W-160) + (Math.random()*150)|0;
          const y = 6 + (Math.random()*64)|0;
          drawPixelRect(bgx, x, y, 4, 4, '#ffb8cf');
          drawPixelRect(bgx, x+1, y+1, 2, 2, '#ffe6ef');
        }
      }
      branchLeft();
      branchRight();

      // Gentle falling petals in background? (STATIC, not moving)
      for (let i=0;i<26;i++){
        const x = (Math.random()*W)|0;
        const y = (Math.random()*H*0.8)|0;
        drawPixelRect(bgx, x, y, 3, 2, 'rgba(255,220,235,0.45)');
      }
    }
    drawBackgroundOnce();

    // ====== UI helper: pixel text ======
    function pixelText(g, text, x, y, size=10, color='#fff', align='center') {
      g.save();
      g.font = `${size}px "Press Start 2P", monospace`;
      g.textAlign = align;
      g.textBaseline = 'top';
      g.fillStyle = 'rgba(0,0,0,0.45)';
      g.fillText(text, x+2, y+2);
      g.fillStyle = color;
      g.fillText(text, x, y);
      g.restore();
    }

    function fancyText(g, text, x, y, size=26, color='#4a1b3f', align='center') {
      g.save();
      g.font = `${size}px "Great Vibes", cursive`;
      g.textAlign = align;
      g.textBaseline = 'top';
      // subtle shadow for readability
      g.fillStyle = 'rgba(255,255,255,0.35)';
      g.fillText(text, x+1, y+1);
      g.fillStyle = color;
      g.fillText(text, x, y);
      g.restore();
    }

    // ====== Pixel art: envelope / letter / scroll ======
    function drawClosedEnvelope(g) {
      // Backdrop already drawn; draw centered envelope
      const cx = W/2, cy = H*0.58;
      const ew = 210, eh = 120;
      const x = (cx - ew/2)|0, y = (cy - eh/2)|0;

      // Envelope body
      drawPixelRect(g, x, y, ew, eh, '#f0d3a4');
      drawPixelRect(g, x+4, y+4, ew-8, eh-8, '#f6e2bf');

      // Flap triangle (closed)
      g.save();
      g.fillStyle = '#e7c996';
      g.beginPath();
      g.moveTo(x, y);
      g.lineTo(x+ew, y);
      g.lineTo(x+ew/2, y+eh/2);
      g.closePath();
      g.fill();
      g.restore();

      // Side folds
      g.save();
      g.fillStyle = 'rgba(205,160,110,0.55)';
      g.beginPath();
      g.moveTo(x, y);
      g.lineTo(x+ew/2, y+eh/2);
      g.lineTo(x, y+eh);
      g.closePath();
      g.fill();
      g.beginPath();
      g.moveTo(x+ew, y);
      g.lineTo(x+ew/2, y+eh/2);
      g.lineTo(x+ew, y+eh);
      g.closePath();
      g.fill();
      g.restore();

      // Heart seal
      drawPixelHeart(g, (cx|0), (y+eh/2+14)|0, 14, 1.0, true);

      pixelText(g, 'Tap to open...', cx, H*0.83, 12, '#ffffff', 'center');
    }

    function drawOpenLetterScreen(g) {
      const cx = W/2, cy = H*0.60;
      const ew = 250, eh = 140;
      const x = (cx - ew/2)|0, y = (cy - eh/2)|0;

      // Envelope base
      drawPixelRect(g, x, y+30, ew, eh-30, '#f0d3a4');
      drawPixelRect(g, x+4, y+34, ew-8, eh-38, '#f6e2bf');

      // Open triangular flap (IMPORTANT: triangle, not rectangle)
      g.save();
      g.fillStyle = '#e7c996';
      g.beginPath();
      g.moveTo(x, y+30);
      g.lineTo(x+ew, y+30);
      g.lineTo(x+ew/2, y-18);
      g.closePath();
      g.fill();
      g.restore();

      // Letter paper peeking out
      drawPixelRect(g, x+16, y-6, ew-32, 84, '#fff6ef');
      drawPixelRect(g, x+18, y-4, ew-36, 80, '#fffaf6');

      // Decorative corners (pixel blossoms)
      for (const p of [
        {px:x+22, py:y+4},{px:x+ew-32, py:y+6},
        {px:x+24, py:y+64},{px:x+ew-34, py:y+62}
      ]) {
        drawPixelRect(g, p.px, p.py, 8, 8, '#ffb8cf');
        drawPixelRect(g, p.px+2, p.py+2, 4, 4, '#ffe6ef');
      }

      // Fancy text on paper
      fancyText(g, 'Dear Yara,', cx, y+6, 26, '#4a1b3f');
      fancyText(g, 'Collect hearts to reveal', cx, y+32, 22, '#4a1b3f');
      fancyText(g, 'something just for you.', cx, y+52, 22, '#4a1b3f');

      // Small heart at bottom
      drawPixelHeart(g, (cx|0), (y+102)|0, 10, 1.0, true);

      pixelText(g, 'Tap to start', cx, H*0.86, 12, '#ffffff', 'center');
    }

    function drawRolledScroll(g) {
      const cx = W/2, cy = H*0.60;

      // Scroll body
      const sw = 220, sh = 90;
      const x = (cx - sw/2)|0, y = (cy - sh/2)|0;

      drawPixelRect(g, x, y, sw, sh, '#e9d2a7');
      drawPixelRect(g, x+4, y+4, sw-8, sh-8, '#f3e3c4');

      // Rolled ends
      drawPixelRect(g, x-18, y+10, 22, sh-20, '#d8b885');
      drawPixelRect(g, x+sw-4, y+10, 22, sh-20, '#d8b885');
      drawPixelRect(g, x-14, y+16, 14, sh-32, '#caa56f');
      drawPixelRect(g, x+sw+4, y+16, 14, sh-32, '#caa56f');

      // Ribbon
      drawPixelRect(g, (cx-16)|0, (cy-8)|0, 32, 16, '#ff4b7d');
      drawPixelRect(g, (cx-12)|0, (cy-4)|0, 24, 8, '#ff7aa0');

      pixelText(g, 'Tap to open...', cx, H*0.83, 12, '#ffffff', 'center');
    }

    function drawOpenScroll(g) {
      const cx = W/2, cy = H*0.58;

      const sw = 280, sh = 140;
      const x = (cx - sw/2)|0, y = (cy - sh/2)|0;

      // Paper
      drawPixelRect(g, x, y, sw, sh, '#f3e3c4');
      drawPixelRect(g, x+4, y+4, sw-8, sh-8, '#fff3da');

      // Top/bottom edges (pixel fray)
      for (let i=0;i<sw;i+=8){
        drawPixelRect(g, x+i, y-4, 6, 4, 'rgba(255,235,205,0.65)');
        drawPixelRect(g, x+i+2, y+sh, 6, 4, 'rgba(255,235,205,0.55)');
      }

      fancyText(g, 'Will you be my Valentine?', cx, y+52, 34, '#4a1b3f');

      // Little heart under text
      drawPixelHeart(g, (cx|0), (y+105)|0, 12, 1.0, true);

      pixelText(g, '❤', cx, y+120, 12, '#ffffff', 'center');
    }

    // ====== Snake game config ======
    const TARGET = 3; // easy for testing; change to 50 later

    const grid = {
      cols: 26,          // includes border ring
      rows: 18,          // includes border ring
      cell: 8,           // pixels per cell (chunky)
      x: 0,
      y: 0
    };
    // Center grid in canvas, leave top space for the counter
    grid.x = ((W - grid.cols * grid.cell) / 2) | 0;
    grid.y = ((H - grid.rows * grid.cell) / 2 + 10) | 0;

    // Snake state
    let snake = [];
    let dir = {x:1, y:0};
    let nextDir = {x:1, y:0};
    let food = {x:0, y:0};
    let hearts = 0;

    // Timing
    let lastTime = 0;
    let acc = 0;
    const STEP = 0.12; // seconds per move (snappy, but playable)

    function resetGame() {
      hearts = 0;

      // Start inside the ring (playable cells are 1..cols-2 and 1..rows-2)
      const sx = 4, sy = 7;
      snake = [
        {x:sx, y:sy},
        {x:sx-1, y:sy},
        {x:sx-2, y:sy}
      ];
      dir = {x:1, y:0};
      nextDir = {x:1, y:0};
      placeFood();
    }

    function placeFood() {
      // Keep food out of the rose ring and out of the snake.
      while (true) {
        const x = 1 + (Math.random() * (grid.cols - 2) | 0);
        const y = 1 + (Math.random() * (grid.rows - 2) | 0);
        if (!snake.some(s => s.x === x && s.y === y)) {
          food.x = x; food.y = y;
          return;
        }
      }
    }

    function isWallCell(x, y) {
      // Rose ring is the outer 1-cell border
      return (x === 0 || y === 0 || x === grid.cols-1 || y === grid.rows-1);
    }

    function stepGame() {
      // Apply buffered direction change (prevents instant reverse)
      dir = nextDir;

      const head = snake[0];
      const nx = head.x + dir.x;
      const ny = head.y + dir.y;

      // Wall collision (rose ring)
      if (isWallCell(nx, ny)) {
        resetGame();
        return;
      }

      // Self collision
      if (snake.some((s, i) => i !== 0 && s.x === nx && s.y === ny)) {
        resetGame();
        return;
      }

      // Move
      snake.unshift({x:nx, y:ny});

      // Eat
      if (nx === food.x && ny === food.y) {
        hearts++;
        placeFood();

        if (hearts >= TARGET) {
          // Win -> scroll
          scene = SCENE.SCROLL_ROLLED;
          updateHudVisibility();
        }
      } else {
        snake.pop();
      }
    }

    // ====== Draw: game world ======
    function drawGridFloor(g) {
      // Pink tile field with LOW opacity grid outlines
      const gx = grid.x, gy = grid.y, cs = grid.cell;

      // Base fill
      drawPixelRect(g, gx, gy, grid.cols*cs, grid.rows*cs, '#ffb3c8');

      // Slight checker variation (still pixel)
      for (let y=0; y<grid.rows; y++) {
        for (let x=0; x<grid.cols; x++) {
          if ((x+y) % 2 === 0) {
            drawPixelRect(g, gx + x*cs, gy + y*cs, cs, cs, 'rgba(255,255,255,0.08)');
          }
        }
      }

      // Low opacity grid lines
      g.save();
      g.strokeStyle = 'rgba(255,255,255,0.10)';
      g.lineWidth = 1;
      g.beginPath();
      for (let x=0; x<=grid.cols; x++) {
        const px = gx + x*cs + 0.5;
        g.moveTo(px, gy);
        g.lineTo(px, gy + grid.rows*cs);
      }
      for (let y=0; y<=grid.rows; y++) {
        const py = gy + y*cs + 0.5;
        g.moveTo(gx, py);
        g.lineTo(gx + grid.cols*cs, py);
      }
      g.stroke();
      g.restore();
    }

    function drawRoseBorder(g) {
      const gx = grid.x, gy = grid.y, cs = grid.cell;

      function roseCell(px, py) {
        // Leaves base
        drawPixelRect(g, px, py, cs, cs, '#2c7a3f');
        drawPixelRect(g, px+1, py+1, cs-2, cs-2, '#2f8a47');

        // Dark vine
        drawPixelRect(g, px+1, py+(cs/2|0), cs-2, 2, '#1f5a2e');

        // Rose blossom (red) + highlight
        drawPixelRect(g, px+(cs/2|0)-1, py+2, 4, 4, '#ff315f');
        drawPixelRect(g, px+(cs/2|0),   py+3, 2, 2, '#ffd0db');

        // Small petal dot
        drawPixelRect(g, px+2, py+cs-3, 2, 2, 'rgba(255,220,235,0.55)');
      }

      for (let x=0; x<grid.cols; x++) {
        // Top row
        roseCell(gx + x*cs, gy + 0*cs);
        // Bottom row
        roseCell(gx + x*cs, gy + (grid.rows-1)*cs);
      }
      for (let y=1; y<grid.rows-1; y++) {
        // Left col
        roseCell(gx + 0*cs, gy + y*cs);
        // Right col
        roseCell(gx + (grid.cols-1)*cs, gy + y*cs);
      }
    }

    function drawSnake(g) {
      const gx = grid.x, gy = grid.y, cs = grid.cell;

      // Connected purple snake (no gaps): draw slightly oversized cells
      for (let i=snake.length-1; i>=0; i--) {
        const s = snake[i];
        const px = gx + s.x*cs;
        const py = gy + s.y*cs;

        const isHead = (i === 0);
        const base = isHead ? '#7e37ff' : '#6b2fe0';
        const inner = isHead ? '#b18cff' : '#9c77ff';

        drawPixelRect(g, px, py, cs+1, cs+1, base);
        drawPixelRect(g, px+2, py+2, cs-3, cs-3, inner);

        // Tiny "face" on head
        if (isHead) {
          const ex = px + (cs/2|0) - 2;
          const ey = py + (cs/2|0) - 1;
          drawPixelRect(g, ex, ey, 2, 2, '#200a2a');
          drawPixelRect(g, ex+4, ey, 2, 2, '#200a2a');
        }
      }
    }

    function drawPixelHeart(g, cx, cy, size, pulse=1.0, hasOutline=false) {
      // Classic 8-bit heart mask (scaled)
      const mask = [
        "01100110",
        "11111111",
        "11111111",
        "11111111",
        "01111110",
        "00111100",
        "00011000",
        "00000000"
      ];
      const scale = Math.max(1, (size / 8) * pulse);
      const ox = (cx - (8*scale)/2) | 0;
      const oy = (cy - (8*scale)/2) | 0;

      if (hasOutline) {
        // simple outline (dark) behind
        g.fillStyle = 'rgba(50,10,30,0.35)';
        for (let y=0; y<8; y++) for (let x=0; x<8; x++) {
          if (mask[y][x] === '1') {
            g.fillRect(ox + x*scale + 1, oy + y*scale + 1, scale, scale);
          }
        }
      }

      g.fillStyle = '#ff2f5e';
      for (let y=0; y<8; y++) {
        for (let x=0; x<8; x++) {
          if (mask[y][x] === '1') {
            g.fillRect(ox + x*scale, oy + y*scale, scale, scale);
          }
        }
      }
      // highlight
      g.fillStyle = 'rgba(255,220,230,0.9)';
      g.fillRect(ox + 2*scale, oy + 2*scale, 2*scale, 1*scale);
    }

    function drawFood(g, t) {
      const gx = grid.x, gy = grid.y, cs = grid.cell;
      const px = gx + food.x*cs + (cs/2|0);
      const py = gy + food.y*cs + (cs/2|0);

      // subtle pulse
      const pulse = 0.92 + 0.08*Math.sin(t*6.0);
      drawPixelHeart(g, px, py, 12, pulse, true);
    }

    function drawCounter(g) {
      // No "Score:" label. Only heart counter.
      g.save();
      g.textAlign = 'left';
      g.textBaseline = 'top';
      g.font = `12px "Press Start 2P", monospace`;
      const text = `❤ ${hearts}/${TARGET}`;
      g.fillStyle = 'rgba(0,0,0,0.45)';
      g.fillText(text, 14, 12);
      g.fillStyle = '#ffffff';
      g.fillText(text, 12, 10);
      g.restore();
    }

    // ====== Input handling ======

    // Tap/click anywhere (menus / scrolls)
    function advanceScene() {
      if (scene === SCENE.MENU_CLOSED) scene = SCENE.MENU_OPEN;
      else if (scene === SCENE.MENU_OPEN) { scene = SCENE.GAME; resetGame(); }
      else if (scene === SCENE.SCROLL_ROLLED) scene = SCENE.SCROLL_OPEN;
      // SCROLL_OPEN is the final screen
      updateHudVisibility();
    }

    // Canvas pointer for tapping menus (ignore gameplay taps; D-pad handles movement)
    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (scene !== SCENE.GAME) advanceScene();
    });

    // D-pad buttons
    function setDirection(dx, dy) {
      // Prevent reversing directly into yourself
      if (dx === -dir.x && dy === -dir.y) return;
      nextDir = {x:dx, y:dy};
    }

    const dpad = document.getElementById('dpad');
    dpad.addEventListener('pointerdown', (e) => {
      const btn = e.target.closest('button[data-dir]');
      if (!btn) return;
      e.preventDefault();
      const d = btn.dataset.dir;
      if (d === 'up') setDirection(0,-1);
      if (d === 'down') setDirection(0, 1);
      if (d === 'left') setDirection(-1,0);
      if (d === 'right') setDirection(1,0);
    });

    // Keyboard arrows (desktop)
    window.addEventListener('keydown', (e) => {
      const k = e.key;
      if (k === 'ArrowUp') setDirection(0,-1);
      else if (k === 'ArrowDown') setDirection(0, 1);
      else if (k === 'ArrowLeft') setDirection(-1,0);
      else if (k === 'ArrowRight') setDirection(1,0);

      // Optional: Enter/Space advances menus
      if ((k === 'Enter' || k === ' ') && scene !== SCENE.GAME) advanceScene();
    });

    // ====== Main loop (requestAnimationFrame) ======
    function drawScene(t) {
      // Background
      ctx.drawImage(bg, 0, 0);

      // Scene overlays
      if (scene === SCENE.MENU_CLOSED) {
        drawClosedEnvelope(ctx);
      } else if (scene === SCENE.MENU_OPEN) {
        drawOpenLetterScreen(ctx);
      } else if (scene === SCENE.GAME) {
        drawGridFloor(ctx);
        drawRoseBorder(ctx);
        drawFood(ctx, t);
        drawSnake(ctx);
        drawCounter(ctx);

        // Small hint (pixel) for desktop
        ctx.save();
        ctx.globalAlpha = 0.75;
        pixelText(ctx, 'Use D-pad or arrow keys', W/2, H-22, 10, '#ffffff', 'center');
        ctx.restore();
      } else if (scene === SCENE.SCROLL_ROLLED) {
        drawRolledScroll(ctx);
      } else if (scene === SCENE.SCROLL_OPEN) {
        drawOpenScroll(ctx);
      }
    }

    function loop(ms) {
      const t = ms / 1000;
      const dt = Math.min(0.05, t - lastTime || 0);
      lastTime = t;

      if (scene === SCENE.GAME) {
        acc += dt;
        while (acc >= STEP) {
          acc -= STEP;
          stepGame();
          if (scene !== SCENE.GAME) { // won mid-step
            acc = 0;
            break;
          }
        }
      }

      // Draw
      drawScene(t);
      requestAnimationFrame(loop);
    }

    // Start on closed envelope
    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>
