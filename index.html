<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Valentine Snake</title>

  <!-- Fancy letter font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">

  <style>
    :root { --safe-top: env(safe-area-inset-top, 0px); --safe-bot: env(safe-area-inset-bottom, 0px); }
    html, body { height:100%; margin:0; background:#09050d; overflow:hidden; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
    #wrap { position:relative; height:100%; width:100%; display:grid; place-items:center; }
    canvas {
      width:min(100vw, calc(100vh * (360/640)));
      height:min(100vh, calc(100vw * (640/360)));
      image-rendering:pixelated;
      background:#000;
      border-radius:16px;
      box-shadow:0 18px 60px rgba(0,0,0,.55);
    }

    /* HUD + overlays */
    #hudTop{
      position:absolute; top:calc(10px + var(--safe-top)); left:12px; right:12px;
      display:none; justify-content:space-between; align-items:center;
      pointer-events:none; color:#fff; font-weight:900; font-size:14px;
      text-shadow:0 2px 10px rgba(0,0,0,.7);
    }
    .pill{
      background:rgba(0,0,0,.35);
      border:1px solid rgba(255,255,255,.10);
      padding:6px 10px;
      border-radius:10px;
    }

    #endPanel{
      position:absolute; left:12px; right:12px; bottom:calc(16px + var(--safe-bot));
      padding:14px; border-radius:16px;
      background:rgba(255,80,160,.22);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(8px);
      display:none;
      pointer-events:auto;
      color:#fff;
    }
    #endPanel.show{ display:block; }
    #endTitle{ font-weight:1000; font-size:18px; margin-bottom:8px; }
    #endMsg{ font-weight:900; opacity:.96; }
    #tiny{ margin-top:8px; opacity:.85; font-size:12px; }
    .btnRow{ margin-top:12px; display:flex; gap:10px; }
    button{
      flex:1;
      border:0;
      border-radius:14px;
      padding:12px 12px;
      font-weight:1000;
      background:rgba(255,255,255,.92);
      color:#140611;
    }
    #yesBtn{ background:#ff5aa6; }
    #noBtn{ position:relative; }
  </style>
</head>

<body>
<div id="wrap">
  <canvas id="c" width="360" height="640"></canvas>

  <div id="hudTop">
    <div class="pill" id="scorePill">Score: 0</div>
    <div class="pill">Goal: 67</div>
  </div>

  <div id="endPanel">
    <div id="endTitle">Yara‚Ä¶</div>
    <div id="endMsg">Will you be my Valentine? üíñ</div>
    <div class="btnRow">
      <button id="yesBtn">üíñ Yes</button>
      <button id="noBtn">üôà No</button>
    </div>
    <div id="tiny">Tip: ‚ÄúNo‚Äù is shy.</div>
  </div>
</div>

<script>
(() => {
  // ===== Personalize =====
  const NAME = "Yara";            // change if you want
  const FROM = "Kalyan";          // optional
  const GOAL = 67;

  // ===== Canvas =====
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha:false });
  ctx.imageSmoothingEnabled = false;
  const W = canvas.width, H = canvas.height;

  // ===== UI =====
  const hudTop = document.getElementById("hudTop");
  const scorePill = document.getElementById("scorePill");
  const endPanel = document.getElementById("endPanel");
  const yesBtn = document.getElementById("yesBtn");
  const noBtn = document.getElementById("noBtn");
  document.getElementById("endTitle").textContent = `${NAME}‚Ä¶`;

  // ===== States =====
  // "menuClosed" -> tap -> "menuOpen" -> tap start -> "game" -> win -> "win"
  let state = "menuClosed";

  // ===== Playfield =====
  const COLS = 20;
  const ROWS = 24;
  const CELL = 18;          // 20*18 = 360 fits perfectly
  const fieldX = 0;
  const fieldY = 160;       // space for sky/menu vibe
  const fieldW = COLS*CELL;
  const fieldH = ROWS*CELL;

  // ===== Background particles (petals) =====
  const petals = [];
  function seedPetals(n){
    for(let i=0;i<n;i++){
      petals.push({
        x: Math.random()*W,
        y: Math.random()*H,
        vx: -0.12 - Math.random()*0.22,
        vy:  0.24 + Math.random()*0.55,
        t: Math.random()*999
      });
    }
  }
  seedPetals(46);

  // ===== Snake game data =====
  let snake, dir, nextDir, food, score, won;

  function resetGame(){
    snake = [{x:10,y:12},{x:9,y:12},{x:8,y:12}];
    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    score = 0;
    won = false;
    food = spawnFood();
    scorePill.textContent = "Score: 0";
  }

  function spawnFood(){
    while(true){
      const fx = (Math.random()*COLS)|0;
      const fy = (Math.random()*ROWS)|0;
      if(!snake?.some(s=>s.x===fx && s.y===fy)){
        return {x:fx,y:fy};
      }
    }
  }

  // ===== Input (tap + swipe) =====
  // Tap for menus
  canvas.addEventListener("click", () => {
    if(state === "menuClosed") state = "menuOpen";
  }, {passive:true});

  // Swipe for snake + tap start button area in open letter
  let sx=0, sy=0;
  canvas.addEventListener("touchstart", (e)=>{
    const t = e.touches[0];
    sx = t.clientX; sy = t.clientY;
  }, {passive:true});

  canvas.addEventListener("touchend", (e)=>{
    const t = e.changedTouches[0];
    const dx = t.clientX - sx;
    const dy = t.clientY - sy;

    // In menuOpen: tap-ish anywhere = start
    if(state === "menuOpen" && Math.abs(dx) < 14 && Math.abs(dy) < 14){
      state = "game";
      hudTop.style.display = "flex";
      endPanel.classList.remove("show");
      resetGame();
      return;
    }

    if(state !== "game") return;

    // swipe controls
    if(Math.abs(dx) < 14 && Math.abs(dy) < 14) return;
    if(Math.abs(dx) > Math.abs(dy)){
      if(dx > 0) setDir(1,0); else setDir(-1,0);
    }else{
      if(dy > 0) setDir(0,1); else setDir(0,-1);
    }
  }, {passive:true});

  function setDir(x,y){
    if(x === -dir.x && y === -dir.y) return; // no reverse
    nextDir = {x,y};
  }

  // Buttons on win panel
  yesBtn.addEventListener("click", () => alert(`Happy Valentine‚Äôs, ${NAME} üíñ\n‚Äî ${FROM}`));
  noBtn.addEventListener("click", () => {
    const x = (Math.random()*50 - 25)|0;
    const y = (Math.random()*24 - 12)|0;
    noBtn.style.transform = `translate(${x}px, ${y}px)`;
    noBtn.textContent = "üôà No (sure?)";
  });

  // ===== Drawing helpers =====
  function drawSky(t){
    // Japanese sunset gradient
    const g = ctx.createLinearGradient(0,0,0,fieldY);
    g.addColorStop(0, "#2e0e45");
    g.addColorStop(0.55, "#ff5fa8");
    g.addColorStop(1, "#ffb07a");
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,fieldY);

    // pixel sun
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.fillRect((W/2-12)|0, 58, 24, 24);

    // sakura tree frame (top corners)
    sakuraCorner(true, t);
    sakuraCorner(false, t);

    // subtle dark band for readability
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(10, 110, W-20, 38);
  }

  function sakuraCorner(left, t){
    const baseX = left ? 0 : W-130;
    const baseY = 0;

    // branch pixels
    ctx.fillStyle = "#2a1428";
    for(let i=0;i<10;i++){
      const x = baseX + (left ? i*10 : 130 - i*10);
      const y = baseY + i*4;
      ctx.fillRect(x, y, 22, 6);
    }

    // blossom clusters (stable pseudo-random)
    const seed = left ? 1337 : 4242;
    let r = seed;
    function rnd(){
      r = (r*1664525 + 1013904223) >>> 0;
      return (r & 0xffff) / 0xffff;
    }

    for(let i=0;i<48;i++){
      const bx = baseX + (rnd()*130)|0;
      const by = baseY + (rnd()*90)|0;
      ctx.fillStyle = (i%3===0) ? "#ffb7d6" : "#ff7bb7";
      ctx.fillRect(bx, by, 6, 6);
      // tiny sparkle sometimes
      if(i%10===0){
        ctx.fillStyle = "rgba(255,255,255,0.35)";
        ctx.fillRect(bx+2, by+1, 1, 1);
      }
    }
  }

  function drawPetals(){
    for(const p of petals){
      p.t += 1;
      p.x += p.vx;
      p.y += p.vy;
      if(p.y > H+10){ p.y = -10; p.x = Math.random()*W; }
      if(p.x < -10){ p.x = W+10; }

      const w = 4 + (Math.sin(p.t*0.03)*1.2);
      ctx.fillStyle = "rgba(255,210,235,0.92)";
      ctx.fillRect(p.x|0, p.y|0, w|0, (w-1)|0);
    }
  }

  function drawBushBorder(){
    // pink bushes around grid
    const pad = 12;
    const bx = fieldX - pad;
    const by = fieldY - pad;
    const bw = fieldW + pad*2;
    const bh = fieldH + pad*2;

    ctx.fillStyle = "#ff78b8";
    ctx.fillRect(bx, by, bw, pad);
    ctx.fillRect(bx, by+bh-pad, bw, pad);
    ctx.fillRect(bx, by, pad, bh);
    ctx.fillRect(bx+bw-pad, by, pad, bh);

    // texture dots on the border only
    for(let i=0;i<230;i++){
      const x = (bx + Math.random()*bw)|0;
      const y = (by + Math.random()*bh)|0;
      const onBorder = (y < by+pad || y > by+bh-pad || x < bx+pad || x > bx+bw-pad);
      if(!onBorder) continue;
      ctx.fillStyle = (i%2===0) ? "#ff9ad0" : "#ff5aa6";
      ctx.fillRect(x, y, 2, 2);
    }
  }

  function drawGrid(){
    // pink floor
    ctx.fillStyle = "#ffb0d7";
    ctx.fillRect(fieldX, fieldY, fieldW, fieldH);

    // low opacity grid lines
    ctx.strokeStyle = "rgba(255,255,255,0.18)";
    ctx.lineWidth = 1;
    for(let c=0;c<=COLS;c++){
      const x = fieldX + c*CELL + 0.5;
      ctx.beginPath(); ctx.moveTo(x, fieldY); ctx.lineTo(x, fieldY+fieldH); ctx.stroke();
    }
    for(let r=0;r<=ROWS;r++){
      const y = fieldY + r*CELL + 0.5;
      ctx.beginPath(); ctx.moveTo(fieldX, y); ctx.lineTo(fieldX+fieldW, y); ctx.stroke();
    }
  }

  function drawMenuClosed(t){
    // Pixel envelope (Minecraft-ish)
    const cx = W/2, cy = 330;
    const bob = Math.sin(t*0.003)*6;

    // envelope shadow
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fillRect((cx-86)|0, (cy+62+bob)|0, 172, 10);

    // envelope body
    ctx.fillStyle = "#f2d7b7";
    ctx.fillRect((cx-90)|0, (cy-40+bob)|0, 180, 120);

    // outline
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.strokeRect((cx-90.5)|0, (cy-40.5+bob)|0, 181, 121);

    // flap lines
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    line(cx-90, cy-40+bob, cx, cy+10+bob);
    line(cx+90, cy-40+bob, cx, cy+10+bob);
    line(cx-90, cy+80+bob, cx, cy+10+bob);
    line(cx+90, cy+80+bob, cx, cy+10+bob);

    // heart seal
    drawPixelHeart(cx, cy+12+bob, 16, t, true);

    // text
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.font = "16px system-ui";
    ctx.fillText("Tap to open‚Ä¶", (W/2-58)|0, 138);
  }

  function drawMenuOpen(t){
    // Open envelope + page (triangle flap)
    const cx = W/2, cy = 350;
    const bob = Math.sin(t*0.003)*4;

    // envelope bottom
    ctx.fillStyle = "#f2d7b7";
    ctx.fillRect((cx-110)|0, (cy+20+bob)|0, 220, 100);
    ctx.strokeStyle = "rgba(0,0,0,0.35)";
    ctx.strokeRect((cx-110.5)|0, (cy+19.5+bob)|0, 221, 101);

    // page
    ctx.fillStyle = "#fff2dc";
    ctx.fillRect((cx-95)|0, (cy-130+bob)|0, 190, 160);
    ctx.strokeStyle = "rgba(0,0,0,0.18)";
    ctx.strokeRect((cx-95.5)|0, (cy-130.5+bob)|0, 191, 161);

    // triangle flap (your fix: not rectangle)
    ctx.fillStyle = "#e7caa8";
    ctx.beginPath();
    ctx.moveTo(cx-110, cy+20+bob);
    ctx.lineTo(cx, cy-30+bob);
    ctx.lineTo(cx+110, cy+20+bob);
    ctx.closePath();
    ctx.fill();
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.stroke();

    // tiny seal at bottom
    drawPixelHeart(cx, cy+92+bob, 10, t, false);

    // fancy note text
    ctx.fillStyle = "rgba(30,10,25,0.95)";
    ctx.textAlign = "center";
    ctx.font = "34px 'Great Vibes', cursive";
    ctx.fillText(`Dear ${NAME},`, cx, cy-78+bob);
    ctx.font = "28px 'Great Vibes', cursive";
    ctx.fillText("please accept this invitation‚Ä¶", cx, cy-40+bob);
    ctx.fillText("I made this just for you.", cx, cy-8+bob);
    ctx.textAlign = "left";

    // start hint
    ctx.fillStyle = "rgba(255,255,255,0.95)";
    ctx.font = "14px system-ui";
    ctx.fillText("Tap to start the game", (W/2-70)|0, 138);
  }

  function drawPixelHeart(x,y,size,t,glow){
    // pulse
    const p = 1 + Math.sin(t*0.01)*0.06;
    const s = size*p;

    ctx.save();
    ctx.translate(x, y);
    const wobble = Math.sin(t*0.02)*0.15;
    ctx.rotate(wobble);

    if(glow){
      ctx.fillStyle = "rgba(255,45,110,0.35)";
      ctx.fillRect((-s*0.8)|0, (-s*0.6)|0, (s*1.6)|0, (s*1.2)|0);
    }

    ctx.fillStyle = "#ff2d6f";
    // simple pixel heart blocks
    ctx.fillRect((-s*0.50)|0, (-s*0.20)|0, (s*0.35)|0, (s*0.35)|0);
    ctx.fillRect(( s*0.15)|0, (-s*0.20)|0, (s*0.35)|0, (s*0.35)|0);
    ctx.fillRect((-s*0.50)|0, ( s*0.15)|0, (s*1.00)|0, (s*0.35)|0);
    ctx.fillRect((-s*0.15)|0, ( s*0.50)|0, (s*0.30)|0, (s*0.30)|0);

    // highlight
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    ctx.fillRect((-s*0.25)|0, (-s*0.08)|0, (s*0.12)|0, (s*0.12)|0);

    ctx.restore();
  }

  function line(x1,y1,x2,y2){
    ctx.beginPath();
    ctx.moveTo(x1|0, y1|0);
    ctx.lineTo(x2|0, y2|0);
    ctx.stroke();
  }

  function drawSnake(t){
    for(let i=snake.length-1;i>=0;i--){
      const s = snake[i];
      const x = fieldX + s.x*CELL;
      const y = fieldY + s.y*CELL;
      const isHead = (i===0);

      ctx.fillStyle = isHead ? "#9d5bff" : "#6f2cff";
      ctx.fillRect(x+2, y+2, CELL-4, CELL-4);

      ctx.strokeStyle = "rgba(255,255,255,0.18)";
      ctx.strokeRect(x+2.5, y+2.5, CELL-5, CELL-5);

      if(isHead){
        ctx.fillStyle = "rgba(255,255,255,0.95)";
        ctx.fillRect(x+6, y+7, 3, 3);
        ctx.fillRect(x+CELL-9, y+7, 3, 3);
        ctx.fillStyle = "#1b0f22";
        ctx.fillRect(x+7, y+8, 1, 1);
        ctx.fillRect(x+CELL-8, y+8, 1, 1);
      }
    }
  }

  function drawFood(t){
    const cx = fieldX + food.x*CELL + CELL/2;
    const cy = fieldY + food.y*CELL + CELL/2;
    drawPixelHeart(cx, cy, 12, t, false);
  }

  // ===== Game step timing =====
  let acc = 0;
  const STEP_MS = 110;

  function stepGame(){
    if(won) return;

    dir = nextDir;
    const head = snake[0];
    const nh = { x: head.x + dir.x, y: head.y + dir.y };

    // wall crash = restart
    if(nh.x < 0 || nh.x >= COLS || nh.y < 0 || nh.y >= ROWS){
      resetGame();
      return;
    }

    // self crash = restart
    for(let i=1;i<snake.length;i++){
      if(snake[i].x === nh.x && snake[i].y === nh.y){
        resetGame();
        return;
      }
    }

    snake.unshift(nh);

    // eat
    if(nh.x === food.x && nh.y === food.y){
      score++;
      scorePill.textContent = `Score: ${score}`;
      food = spawnFood();

      // little ‚Äúeat burst‚Äù = extra petals
      for(let i=0;i<6;i++){
        petals.push({
          x: fieldX + nh.x*CELL + CELL/2,
          y: fieldY + nh.y*CELL + CELL/2,
          vx: -0.6 + Math.random()*0.4,
          vy:  0.2 + Math.random()*0.5,
          t: Math.random()*999
        });
      }

      if(score >= GOAL){
        won = true;
        state = "win";
        endPanel.classList.add("show");
      }
    }else{
      snake.pop();
    }
  }

  // ===== Main loop =====
  function loop(t){
    ctx.clearRect(0,0,W,H);

    drawSky(t);
    drawBushBorder();
    drawGrid();
    drawPetals();

    if(state === "menuClosed"){
      hudTop.style.display = "none";
      endPanel.classList.remove("show");
      drawMenuClosed(t);
    } else if(state === "menuOpen"){
      hudTop.style.display = "none";
      endPanel.classList.remove("show");
      drawMenuOpen(t);
    } else if(state === "game"){
      // step
      acc += 16.7;
      if(acc >= STEP_MS){
        acc = 0;
        stepGame();
      }
      drawFood(t);
      drawSnake(t);
    } else if(state === "win"){
      // freeze with glow
      drawFood(t);
      drawSnake(t);
      ctx.fillStyle = "rgba(255,90,166,0.18)";
      ctx.fillRect(0,0,W,H);
    }

    requestAnimationFrame(loop);
  }

  // Start
  resetGame();
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
